Walky Protocol

Base exchange unit is in Line-Delimited JSON.

Each line should be an array.

The basic structure of the array would look something like this.

[ PayloadType:Integer, Payload:Object, MessageID:String, ...Arguments:Optional ]

This will be applied both to queries and responses.

The PayloadType:Integer will tell the receiving system what type of data is found
in the payload.

== PayloadType:Integer ==

< 0: Error conditions
0..9: Frequently used messages
>= 10: System related

Object Method Invocation: 0
> [ 0, ObjectID:HexString, Function:String, args:List, kwargs:Object, MessageID:String ]
> Request an object method to be executed
> ObjectID: string identifying the object holding the function to execute
> Function: string name of the function to call
> args: (optional) array of normalized positional values to pass to the class method
> kwargs: (optional) dict of normalized values to pass to the class method
> MessageID: a string value that uniquely identifies the request. Useful for async libraries.

Primitive: 1
> Payload can be used directly without any additional processing

Contains Distributed Object: 2
> Payload CONTAINS distributed objects, further processing required

Distributed Object: 3
> Payload IS a distributed object, further processing required
> Expanded, the structure would look like:
> [3, ObjectID:Integer, ObjectAttributeHash:String, MessageID:String]

Object Deleted: 8
> Returned as confirmation that an object has been freed
> from the server's memory.

Object Method: 9
> Special return code for attribute query telling the requestor that the 
> result is an object method.
> No payload is required or provided in this case.

Event: 11
> Payload has information related to an subscribed event. Payload to be treated like a Distributed Object

System: 12
> Payload has system related information. Payload to be treated like a Distributed Object

Error: -1
> Payload has system related information. Payload to be treated like a Distributed Object

Error: -XXX
> System can also use HTTP error status codes (excepting the 200/300 series)

Note that the structure can be nested.

For instance, take the example of a list of objects. Expanded

[
  2,
  [
    [3,'1234'],
    [3,'1235']
  ]
]

And for a dict:

[
  2,
  {
    'key1': [3,'1234'],
    'key2': [3,'1235']
  }
]

MessageID:String is just a unique string representation for the string. 

This makes it much easier for async requests to receive the response associated with them.

If MessageIDs are not being used, the value is not present.

=== Request Messages ===

[ 0, ObjectID:HexString, Function:String, MessageID:String, args:List, kwargs:Object ]

ObjectID: string identifying the object holding the function to execute
Function: string name of the function to call
MessageID: a string value that uniquely identifies the request. Useful for async libraries.
args: (optional) array of normalized positional values to pass to the class method
kwargs: (optional) dict of normalized values to pass to the class method

Note that args and kwargs may contain distributed objects. The the arguments must be encoded the same as payload format used for responses.

=== Special Objects ===

There are a few objects that are always present.

They have been given special ObjectIDs that are easily recognizable.

They are:

"?": Inspection

==== Interrogation Object ====

This is a core object. It's purpose is to yield metadata associated with
registered objects in the system.

[ 0, "?", "dir", [ 0, "ObjectID:HexString" ], MessageID:String ]

Returns a list of all the attributes of the object.

MessageID: (optional) a string value that uniquely identifies the request. Useful for async libraries.

This effectively is like calling 'dir'.

The server's response should be:

[ 1, [ attr1, ..., attrn ], MessageID:String(if any) ]

[ "?", "ObjectID:HexString.Attribute:String" ]

We're requesting information on the attribute.

If the attribute is data structure, the system will return a standard response.

If the attribute is an object method, then the system will return a message code like:

[ 9 ]

==== Attribute Setting Object ====

This is a core object. It's purpose is to set attributes associated with 
regisered objects in the system.

[ 0, "?", "=", [ "ObjectID:HexString", "Attribute:String", PayLoad:Object ],  MessageID:String ]

This will set the object's attribute to a particular value.

MessageID: (optional) a string value that uniquely identifies the request. Useful for async libraries.

This can potentially be a dangerous ability so it's controlled by a set of permissions.

==== Deletion Object ====

Also a core object. This lives as a way to help the garbage collector know when
an object no longer must be stored in memory.

[ 0, "?", "del", 'ObjectID:HexString', MessageID:String ]

Removes the object from the reference, effectively "free" the resource.

MessageID: (optional) a string value that uniquely identifies the request. Useful for async libraries.

You will not be able to use this record again.

The server's response should be:

[ 8, MessageID:String(if any) ]

==== State Management ====

Networks are not necessarily stable, anything from a temporary hiccup to hitting refresh during a websock connection can cause disruption.

To allow the reconnection from a broken state, a method of restoring state is provided.

[ 0, "@", Function:String ]

===== Functions =====

@.resumeable( Seconds:Integer )

Request the current session to be retained for up to Seconds:Integer seconds.

If successful, the server's response should be:

[ 1, SessionKey:String, MessageID:String(if any) ]

SessionKey is a unique identifier that allows the user to resume to a session

In some cases no sessionkey may be available, such as when the user is not logged in or the port is in unrecoverable error state.

@.resume( SessionKey:String )





